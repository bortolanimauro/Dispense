\documentclass[12pt,a4paper]{extarticle}

% ====================================
% PACCHETTI PER ACCESSIBILITA'
% ====================================
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{graphicx}

% Font Helvetica (simile a Verdana, sans-serif leggibile)
\usepackage[scaled]{helvet}
\renewcommand{\familydefault}{\sfdefault}

% Interlinea 1.5
\usepackage{setspace}
\onehalfspacing

% Margini più ampi per leggibilità
\usepackage[top=3cm, bottom=3cm, left=3cm, right=3cm]{geometry}

% Colori pastello per box (più soft per dislessici)
\usepackage{xcolor}
\definecolor{lightblue}{RGB}{230,240,250}
\definecolor{lightred}{RGB}{255,235,235}
\definecolor{lightgreen}{RGB}{235,250,235}
\definecolor{lightgray}{RGB}{245,245,245}

% Box con colori accessibili
\usepackage{tcolorbox}
\newtcolorbox{esercizio}{
    colback=lightblue,
    colframe=blue!50!black,
    boxrule=1.5pt,
    arc=3mm,
    title=\textbf{Esercizio Pratico},
    fonttitle=\bfseries\Large
}

\newtcolorbox{attenzione}{
    colback=lightred,
    colframe=red!60!black,
    boxrule=1.5pt,
    arc=3mm,
    title=\textbf{ATTENZIONE!},
    fonttitle=\bfseries\Large
}

\newtcolorbox{consiglio}{
    colback=lightgreen,
    colframe=green!60!black,
    boxrule=1.5pt,
    arc=3mm,
    title=\textbf{Consiglio del Programmatore},
    fonttitle=\bfseries\Large
}

% Codice con font monospace leggibile
\usepackage{listings}
\lstdefinestyle{csharp}{
    language=[Sharp]C,
    basicstyle=\ttfamily\fontsize{12}{14}\selectfont,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black},
    stringstyle=\color{red!80!black},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=10pt,
    backgroundcolor=\color{lightgray},
    frame=single,
    tabsize=4,
    breaklines=true,
    captionpos=b,
    showstringspaces=false,
    xleftmargin=2em,
    framexleftmargin=1.5em
}

% Liste con più spazio
\usepackage{enumitem}
\setlist{itemsep=0.5em, parsep=0.3em}

% Titoli più grandi e spaziati
\usepackage{titlesec}
\titleformat{\part}[display]
  {\normalfont\huge\bfseries}{\partname\ \thepart}{20pt}{\Huge}
\titlespacing*{\part}{0pt}{50pt}{40pt}

\titleformat{\section}
  {\normalfont\LARGE\bfseries}{\thesection}{1em}{}
\titlespacing*{\section}{0pt}{3.5ex plus 1ex minus .2ex}{2.3ex plus .2ex}

\titleformat{\subsection}
  {\normalfont\Large\bfseries}{\thesubsection}{1em}{}
\titlespacing*{\subsection}{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\titleformat{\subsubsection}
  {\normalfont\large\bfseries}{\thesubsubsection}{1em}{}
\titlespacing*{\subsubsection}{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

% Spazio tra paragrafi invece di rientro
\setlength{\parindent}{0pt}
\setlength{\parskip}{1em}

% Link senza box (più pulito)
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue!60!black,
    urlcolor=blue!60!black,
    bookmarks=true,
    pdfborder={0 0 0}
}

% Header e footer semplificati
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\textsf{Dispensa Windows Forms}}
\fancyhead[R]{\textsf{C\#}}
\fancyfoot[C]{\Large\thepage}
\renewcommand{\headrulewidth}{0.5pt}

% ====================================
% PREVENZIONE VEDOVE NEI TITOLI
% ====================================

% Pacchetto per migliorare la micro-tipografia
\usepackage{microtype}

% Permette ai titoli di essere più flessibili nella spaziatura
\usepackage{ragged2e}

% Modifica i titoli per usare RaggedRight (con sillabazione)
\titleformat{\section}
  {\normalfont\LARGE\bfseries\RaggedRight}{\thesection}{1em}{}
\titlespacing*{\section}{0pt}{3.5ex plus 1ex minus .2ex}{2.3ex plus .2ex}

\titleformat{\subsection}
  {\normalfont\Large\bfseries\RaggedRight}{\thesubsection}{1em}{}
\titlespacing*{\subsection}{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\titleformat{\subsubsection}
  {\normalfont\large\bfseries\RaggedRight}{\thesubsubsection}{1em}{}
\titlespacing*{\subsubsection}{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}


% Informazioni documento
\title{\textbf{\Huge Programmare con C\# e\\le Windows Forms\\[0.5em]\LARGE Animazioni e Grafica Interattiva}}
\author{\Large Dispensa Didattica}
\date{\Large\today}

\begin{document}

\maketitle
\thispagestyle{empty}
\newpage

\tableofcontents
\newpage

% ====================================
% INDICE DELLA DISPENSA
% ====================================
\section*{Indice della Dispensa}
\addcontentsline{toc}{section}{Indice della Dispensa}

\subsection*{Parte 1: Le Basi della Grafica (L'Interfaccia)}
\begin{enumerate}
    \item Benvenuti nel mondo Windows Forms
    \begin{itemize}
        \item Cos'è una "finestra" (GUI) e perché si usa
        \item Come aprire Visual Studio e creare il primo progetto
    \end{itemize}
    
    \item Gli attrezzi del mestiere: I Controlli
    \begin{itemize}
        \item La Form: Il nostro foglio di lavoro
        \item Label, TextBox e Button
        \item La Toolbox
    \end{itemize}
    
    \item Far succedere le cose: Gli Eventi
    \begin{itemize}
        \item Il concetto di "Click"
        \item Il primo esercizio: "L'app che ti saluta"
    \end{itemize}
\end{enumerate}

\subsection*{Parte 2: Organizzare il Codice (Le Classi e le Liste)}
\begin{enumerate}[resume]
    \item Le Classi: Creare il "Modello" di un oggetto
    \item Le Liste: Una scatola per tanti oggetti
\end{enumerate}

\subsection*{Parte 3: Disegnare e Muovere (La Logica del Gioco)}
\begin{enumerate}[resume]
    \item Disegnare con i Pixel
    \item Il Timer: L'orologio del Programmatore
    \item Gestire la Tastiera
\end{enumerate}

\subsection*{Parte 4: Il Progetto Finale (Quadratini e Rimbalzi)}
\begin{enumerate}[resume]
    \item Creare la Classe "Quadratino"
    \item La Matematica del Rimbalzo
    \item Gli Ostacoli e le Collisioni
    \item Mettere tutto insieme
\end{enumerate}

\newpage

% ====================================
% PARTE 1
% ====================================
\part{Le Basi della Grafica (L'Interfaccia)}

\section{Benvenuti nel mondo Windows Forms}

Le Windows Forms (chiamate spesso \textbf{WinForms}) sono una tecnologia che ci permette di creare programmi per il computer con un'interfaccia grafica.

\subsection{Cosa significa "Interfaccia Grafica" (GUI)?}

Invece di avere solo una schermata nera dove scrivere comandi difficili, usiamo le \textbf{finestre}. In una finestra possiamo inserire pulsanti da cliccare, caselle dove scrivere e immagini che si muovono. È il modo in cui funzionano quasi tutti i programmi che usi ogni giorno sul PC.

\subsection{Come creare il tuo primo progetto}

Per iniziare a programmare, dobbiamo preparare il nostro "laboratorio" in Visual Studio:

\begin{enumerate}
    \item Apri \textbf{Visual Studio} sul tuo computer.
    
    \item Clicca su \textbf{"Crea un nuovo progetto"}.
    
    \item Cerca nella lista: \textbf{"App Windows Forms (.NET Framework)"} oppure \textbf{"Windows Forms App"}.
    
    \item Dai un nome al tuo lavoro (per esempio: \texttt{LaMiaPrimaApp}) e clicca su \textbf{Crea}.
    
    \item Dopo pochi istanti, vedrai apparire una finestra vuota al centro dello schermo: quella è la tua \texttt{Form1}, la base di tutto il tuo programma.
\end{enumerate}

% ====================================
\section{Gli attrezzi del mestiere: I Controlli}

Quando apriamo un progetto, Visual Studio ci mette a disposizione una \textbf{Toolbox} (la nostra Scatola degli Attrezzi). Da qui possiamo trascinare gli oggetti direttamente sulla nostra finestra (Form). Questi oggetti si chiamano \textbf{Controlli}.

\subsection{La Form: Il nostro "Foglio di Lavoro"}

La \textbf{Form} è la finestra principale dell'applicazione. È come un contenitore che ospita tutti gli altri oggetti. Possiamo cambiare il suo aspetto andando nella finestra delle \textbf{Proprietà} (di solito si trova in basso a destra):

\begin{itemize}
    \item \textbf{Text}: Cambia il titolo che appare in alto sulla finestra (es: "Il mio Gioco").
    
    \item \textbf{BackColor}: Serve per cambiare il colore dello sfondo (es: Bianco o Blu).
    
    \item \textbf{Size}: Serve per decidere quanto deve essere grande la finestra.
\end{itemize}

\subsection{I Controlli più importanti}

Ecco gli strumenti che useremo più spesso:

\begin{enumerate}
    \item \textbf{Label} (Etichetta): Serve per mostrare dei testi fissi che l'utente non può cambiare. Ad esempio: "Inserisci il tuo nome".
    
    \item \textbf{TextBox} (Casella di testo): È una casella bianca dove chi usa il programma può scrivere parole o numeri.
    
    \item \textbf{Button} (Pulsante): È il classico bottone da cliccare per far succedere qualcosa (es: un pulsante "Saluta" o "Inizia Gioco").
    
    \item \textbf{PictureBox} (Riquadro Immagine): Questo è fondamentale per noi! È un rettangolo speciale dove andremo a "disegnare" i nostri pixel o quadratini che si muovono.
\end{enumerate}

\subsection{Focus sulla PictureBox: Il nostro "Canvas" per disegnare}

La \textbf{PictureBox} sarà il nostro strumento principale per creare 
giochi e animazioni. È come una tela bianca dove potremo disegnare 
tutto quello che vogliamo pixel per pixel.

\subsubsection{Come aggiungere una PictureBox}

\textbf{Procedura passo-passo:}

\begin{enumerate}
    \item Apri la \textbf{Toolbox} (la barra a sinistra con tutti 
          i controlli disponibili).
    
    \item Cerca "\textbf{PictureBox}" nella lista. Di solito si trova 
          nella categoria "Common Controls" (Controlli Comuni).
    
    \item \textbf{Trascina la PictureBox} sulla tua Form. Apparirà 
          un rettangolo grigio con una piccola icona.
    
    \item \textbf{Ridimensiona} la PictureBox trascinando i bordi. 
          Per i nostri progetti di animazione, ti consiglio di farla 
          grande: almeno 600 pixel di larghezza e 400 di altezza.
    
    \item La PictureBox si chiamerà automaticamente \texttt{pictureBox1}.
\end{enumerate}

\subsubsection{Configurare le proprietà della PictureBox}

Dopo aver aggiunto la PictureBox, dobbiamo configurarla correttamente:

\begin{enumerate}
    \item \textbf{Clicca sulla PictureBox} per selezionarla.
    
    \item Vai nella finestra delle \textbf{Proprietà} (di solito 
          in basso a destra).
    
    \item Imposta queste proprietà importanti:
    
    \begin{itemize}
        \item \textbf{(Name)}: Puoi lasciarla come \texttt{pictureBox1} 
              o darle un nome più descrittivo come \texttt{areaGioco}.
        
        \item \textbf{Size}: Imposta le dimensioni. Esempio: 
              \texttt{600, 400} (larghezza 600, altezza 400).
        
        \item \textbf{BackColor}: Imposta su \texttt{White} (bianco) 
              per avere uno sfondo pulito.
        
        \item \textbf{BorderStyle}: Imposta su \texttt{FixedSingle} 
              per avere un bordo visibile che delimita l'area di gioco.
        
        \item \textbf{Location}: Posiziona la PictureBox dove preferisci 
              sulla Form (puoi anche trascinarla direttamente).
    \end{itemize}
\end{enumerate}

\subsubsection{Perché la PictureBox è speciale?}

A differenza di un semplice \texttt{Panel} o di un'area vuota della Form, 
la PictureBox ha una proprietà magica chiamata \textbf{Image}.

Questa proprietà ci permette di:
\begin{itemize}
    \item Assegnare un'immagine (Bitmap) che abbiamo creato nel codice
    \item Modificare i singoli pixel dell'immagine
    \item Mostrare le modifiche all'utente in tempo reale
\end{itemize}

\textbf{Schema del funzionamento:}

\begin{lstlisting}[caption={Come funziona la PictureBox}]
// 1. Creiamo un foglio digitale (Bitmap)
Bitmap foglio = new Bitmap(600, 400);

// 2. Disegniamo sul foglio (modifichiamo i pixel)
foglio.SetPixel(100, 100, Color.Red);

// 3. Mostriamo il foglio nella PictureBox
pictureBox1.Image = foglio;
// Magia! Il pixel rosso appare sullo schermo!
\end{lstlisting}

\begin{consiglio}
\textbf{Dimensioni consigliate per progetti diversi:}

\begin{itemize}
    \item \textbf{Gioco semplice}: 400×300 pixel (più veloce da disegnare)
    \item \textbf{Animazione standard}: 600×400 pixel (buon compromesso)
    \item \textbf{Progetto complesso}: 800×600 pixel (più spazio ma più lento)
\end{itemize}

Ricorda: più grande è la PictureBox, più pixel dobbiamo colorare, 
quindi più lento sarà il programma. Inizia sempre con dimensioni medie!
\end{consiglio}

\subsubsection{Verifica che funzioni}

Per testare che la PictureBox sia configurata correttamente, 
prova questo codice nel \texttt{Form1\_Load}:

\begin{lstlisting}[caption={Test della PictureBox}]
private void Form1_Load(object sender, EventArgs e)
{
    // Creiamo un foglio di prova
    Bitmap test = new Bitmap(pictureBox1.Width, 
                             pictureBox1.Height);
    
    // Coloriamo tutto di giallo
    using (Graphics g = Graphics.FromImage(test))
    {
        g.Clear(Color.Yellow);
    }
    
    // Mostriamo nella PictureBox
    pictureBox1.Image = test;
    
    // Se vedi un rettangolo giallo, funziona!
}
\end{lstlisting}

Se premi F5 e vedi la PictureBox completamente gialla, sei pronto 
per iniziare a disegnare!

\subsection{Come personalizzare i controlli}

Ogni volta che aggiungi un pulsante o una casella di testo, puoi cambiare le sue \textbf{Proprietà} proprio come abbiamo fatto con la Form:

\begin{itemize}
    \item Puoi cambiare il colore di un pulsante.
    \item Puoi cambiare la scritta sopra di esso.
\end{itemize}

\begin{consiglio}
Dai sempre un nome chiaro ai tuoi controlli! Ad esempio, chiama un pulsante \texttt{btnSaluta} invece di lasciarlo come \texttt{button1}. Ti aiuterà a non confonderti quando scriverai il codice.
\end{consiglio}

\subsection{Cosa abbiamo imparato}

\begin{itemize}
    \item Le WinForms servono per creare programmi con finestre.
    \item La Form è la nostra finestra principale.
    \item Usiamo la Toolbox per trascinare pulsanti, scritte e immagini.
    \item Ogni oggetto ha delle Proprietà per cambiare colore, testo e dimensioni.
\end{itemize}

% ====================================
\subsection{Esercizio Pratico: La tua prima App "Saluta-Tutti"}

\begin{esercizio}
In questo esercizio creeremo un piccolo programma che chiede il nome all'utente e, quando si preme un pulsante, mostra un saluto personalizzato.

\textbf{Obiettivo:} Imparare a:
\begin{enumerate}
    \item Aggiungere controlli sulla finestra (Form) usando la Toolbox.
    \item Cambiare le Proprietà (come i testi e i colori).
    \item Scrivere il primo codice per far reagire il pulsante al "Click".
\end{enumerate}

\textbf{Istruzioni Passo-Passo:}
\begin{enumerate}
    \item \textbf{Crea il Progetto}: Apri Visual Studio e crea un nuovo progetto di tipo App Windows Forms.
    
    \item \textbf{Prepara la Finestra}:
    \begin{itemize}
        \item Clicca sulla Form (la finestra vuota).
        \item Nella finestra delle Proprietà, cerca la voce \texttt{Text} e scrivi "La mia App di Saluto".
    \end{itemize}
    
    \item \textbf{Aggiungi gli "Attrezzi" (Controlli)}: Trascina dalla Toolbox questi tre elementi sulla Form:
    \begin{itemize}
        \item Una \textbf{Label}: Cambia la sua proprietà \texttt{Text} in "Come ti chiami?".
        \item Una \textbf{TextBox}: Qui è dove lo studente scriverà il suo nome.
        \item Un \textbf{Button}: Cambia la sua proprietà \texttt{Text} in "Cliccami!".
        \item Una seconda \textbf{Label}: Questa servirà per il risultato. Cancella il suo testo iniziale (lasciala vuota) e chiamala nella proprietà \texttt{(Name)} come \texttt{lblRisultato}.
    \end{itemize}
\end{enumerate}
\end{esercizio}

\subsubsection{La Soluzione (Il Codice)}

Per scrivere il codice, fai \textbf{doppio clic} sul pulsante che hai creato. Visual Studio aprirà automaticamente la pagina del codice e creerà una funzione chiamata \texttt{button1\_Click}.

Inserisci questo codice tra le parentesi graffe \texttt{\{ \}}:

\lstset{style=csharp}
\begin{lstlisting}[caption={Evento Click del pulsante}]
private void button1_Click(object sender, EventArgs e)
{
    // Prendiamo il nome scritto nella TextBox 
    // e mettiamolo in una Label di saluto
    label2.Text = "Ciao, " + textBox1.Text + 
                  "! Benvenuto nel mondo C#!";
    
    // In alternativa, possiamo far apparire 
    // una finestrella pop-up
    MessageBox.Show("Hai premuto il pulsante!"); 
}
\end{lstlisting}

\subsubsection{Spiegazione semplice del codice}

\begin{itemize}
    \item \texttt{textBox1.Text}: Serve per "leggere" quello che l'utente ha scritto dentro la casella.
    
    \item \texttt{label2.Text = ...}: Serve per "scrivere" o cambiare il testo della nostra etichetta a schermo.
    
    \item \texttt{MessageBox.Show(...)}: Crea una piccola finestra di avviso che compare sopra il programma.
\end{itemize}

\subsubsection{Come verificare se funziona}

Premi il tasto \textbf{F5} (o il tasto \textbf{Start} in alto). Se tutto è corretto:

\begin{enumerate}
    \item Si aprirà la tua finestra.
    \item Scrivi il tuo nome nella casella bianca.
    \item Clicca sul pulsante.
    \item Magia! Apparirà il saluto personalizzato sulla Label che prima era vuota.
\end{enumerate}

% ====================================
\section{Far succedere le cose: Gli Eventi}

In questa parte impareremo il "cuore" della programmazione: come far reagire il computer quando noi facciamo qualcosa.

\subsection{Cos'è un Evento?}

Un \textbf{evento} è un'azione che accade mentre il programma è acceso. Immagina che il computer stia "in ascolto" e aspetti che tu faccia qualcosa. Ad esempio:

\begin{itemize}
    \item Fare un \textbf{Click} su un pulsante.
    \item Premere un tasto sulla tastiera (come le frecce per muovere un personaggio).
    \item Aprire la finestra del programma (evento \textbf{Load}).
\end{itemize}

\subsection{Il protagonista: L'evento Click}

L'evento più usato in assoluto è il \textbf{Click}. Si attiva quando l'utente preme un pulsante (Button) con il mouse.

\subsubsection{Come si crea un evento Click?}

\begin{enumerate}
    \item Vai sulla tua finestra (Form) in Visual Studio.
    \item Fai \textbf{doppio clic veloce} sul pulsante che hai creato.
    \item Magia! Visual Studio ti porterà nel codice e creerà una funzione "vuota" pronta per essere riempita.
\end{enumerate}

Esempio di codice:

\begin{lstlisting}[caption={Esempio di evento Click}]
private void button1_Click(object sender, EventArgs e)
{
    // Tutto quello che scrivi qui dentro succedera' 
    // QUANDO clicchi il pulsante!
    MessageBox.Show("Hai cliccato il pulsante!"); 
}
\end{lstlisting}

\subsection{Altri eventi importanti per i nostri progetti}

Oltre al click, useremo degli eventi speciali per creare giochi o app animate:

\begin{enumerate}
    \item \textbf{Load} (Caricamento): Questo evento scatta una sola volta, proprio quando il programma si avvia. Lo useremo per preparare i nostri quadratini e decidere i loro colori iniziali.
    
    \item \textbf{KeyDown} (Tasto Premuto): Serve per sentire se stai premendo le frecce della tastiera. Ad esempio, possiamo dire al computer: "Se premi la freccia Su, sposta il quadratino verso l'alto".
    
    \item \textbf{Tick} (Il battito del Timer): È un evento speciale che si ripete da solo ogni pochi millisecondi. È fondamentale per le animazioni, perché ci permette di muovere gli oggetti continuamente senza dover cliccare nulla.
\end{enumerate}

\begin{consiglio}
Ogni volta che crei un evento, Visual Studio gli dà un nome standard (come \texttt{button1\_Click}). Per non confonderti, ricorda di dare ai tuoi pulsanti nomi chiari nella finestra delle proprietà, come \texttt{btnInizia} o \texttt{btnSaluta}. Così il tuo codice sarà ordinato e facile da leggere!
\end{consiglio}

\subsection{Mini-Esercizio: Cambia Colore!}

Prova a creare un pulsante che, ogni volta che viene cliccato, cambia il colore dello sfondo della finestra.

\textbf{Aiuto:} Nel codice del Click dovrai scrivere: \texttt{this.BackColor = Color.Red;}

\subsection{Esercizio: Il Pulsante "Cambia-Colore"}

\begin{esercizio}
\textbf{Obiettivo:} Creare due pulsanti che cambiano il colore della finestra quando vengono cliccati.

\textbf{Istruzioni:}
\begin{enumerate}
    \item Trascina due pulsanti sulla Form.
    \item Cambia il testo del primo in "Rosso" e del secondo in "Verde".
    \item Fai doppio clic sul primo pulsante e scrivi la soluzione.
\end{enumerate}

\textbf{Soluzione:}
\end{esercizio}

\begin{lstlisting}[caption={Cambiare colore della Form}]
private void button1_Click(object sender, EventArgs e)
{
    // "this" indica la finestra stessa
    this.BackColor = Color.Red; 
}

private void button2_Click(object sender, EventArgs e)
{
    // Cambia il colore in verde
    this.BackColor = Color.Green; 
}
\end{lstlisting}

\subsection{Cosa abbiamo imparato}

\begin{itemize}
    \item Gli eventi sono le risposte del computer alle nostre azioni.
    \item Il doppio clic su un oggetto è il modo più veloce per creare un evento.
    \item Esistono eventi per il mouse (Click), per la tastiera (KeyDown) e per il tempo (Tick del Timer).
\end{itemize}

\newpage

% ====================================
% PARTE 2
% ====================================
\part{Organizzare il Codice (Le Classi e le Liste)}

\section{Le Classi: Creare il "Modello" di un oggetto}

In programmazione, una \textbf{Classe} è come una "fabbrica" o uno stampo. Serve a descrivere come deve essere fatto un oggetto e cosa può fare.

\begin{itemize}
    \item \textbf{Le Proprietà}: Sono le caratteristiche (es: il nome, il colore, la posizione).
    
    \item \textbf{I Metodi}: Sono le azioni che l'oggetto sa compiere (es: camminare, salutare).
    
    \item \textbf{Il Costruttore}: È un comando speciale che serve a creare l'oggetto "nuovo di zecca" assegnandogli subito i suoi valori iniziali.
\end{itemize}

\textbf{Esempio reale:} La classe "Automobile" descrive che ogni auto ha un colore e una velocità. La tua macchina specifica è l'oggetto creato da quella classe.

\subsection{Esercizio: Crea la tua Classe "Studente"}

\begin{esercizio}
\textbf{Obiettivo:} Creare una classe che rappresenti uno studente con un nome e un voto.

\textbf{Istruzioni:}
\begin{enumerate}
    \item Vai nel codice del tuo progetto.
    \item Fuori dalla zona della Form, scrivi la classe Studente.
    \item Crea un pulsante nella Form che, quando cliccato, crea uno studente e mostra i suoi dati.
\end{enumerate}
\end{esercizio}

\textbf{Soluzione:}

\begin{lstlisting}[caption={Classe Studente}]
// 1. Definiamo la "ricetta" dello studente
class Studente
{
    public string Nome;
    public int Voto;

    // Metodo per mostrare le informazioni
    public string Scheda()
    {
        return Nome + " - Voto: " + Voto;
    }
}

// 2. Codice dentro il pulsante per usare la classe
private void btnCrea_Click(object sender, EventArgs e)
{
    // Creiamo l'oggetto
    Studente s1 = new Studente(); 
    s1.Nome = "Mario";
    s1.Voto = 8;
    
    // Mostra: Mario - Voto: 8
    MessageBox.Show(s1.Scheda()); 
}
\end{lstlisting}

% ====================================
\section{Le Liste: Una scatola per tanti oggetti}

A volte non ci basta un solo oggetto, ma ne servono tanti (pensa a una lista della spesa o a tanti nemici in un gioco). Per questo usiamo la \textbf{List}.

A differenza di un contenitore rigido, la lista è \textbf{dinamica}: puoi aggiungere o togliere elementi quando vuoi.

\subsection{Comandi principali da ricordare}

\begin{itemize}
    \item \textbf{Add}: Per aggiungere qualcuno alla lista.
    \item \textbf{Remove}: Per togliere qualcuno.
    \item \textbf{Count}: Per sapere quanti elementi ci sono in totale.
    \item \textbf{Indice [i]}: Ricorda che il computer inizia a contare da 0! Il primo della lista è sempre lo studente numero 0.
\end{itemize}

\subsection{Esercizio: La Lista dei Nomi}

\begin{esercizio}
\textbf{Obiettivo:} Creare un'app dove scrivi un nome in una TextBox, premi un pulsante e il nome finisce in una ListBox (un elenco visibile).

\textbf{Istruzioni:}
\begin{enumerate}
    \item Aggiungi una TextBox, un Button e una ListBox sulla Form.
    \item Crea una lista di parole (stringhe) all'inizio del codice.
\end{enumerate}
\end{esercizio}

\textbf{Soluzione:}

\begin{lstlisting}[caption={Gestione di una lista}]
// Creiamo la nostra "scatola" vuota
List<string> nomi = new List<string>();

private void btnAggiungi_Click(object sender, EventArgs e)
{
    // Aggiungiamo il nome scritto nella casella
    nomi.Add(textBox1.Text); 
    
    // Aggiorniamo la ListBox per far vedere 
    // i nomi a schermo
    listBox1.DataSource = null;              
    listBox1.DataSource = nomi;  
}
\end{lstlisting}

\subsection{Cosa abbiamo imparato in questa parte}

\begin{itemize}
    \item La \textbf{Classe} è il modello (lo stampo), l'\textbf{Oggetto} è ciò che creiamo.
    
    \item Le \textbf{Liste} servono a gestire tanti oggetti insieme in modo ordinato.
    
    \item Possiamo collegare le liste ai componenti grafici come la ListBox per vedere i nostri dati.
\end{itemize}

\newpage

% ====================================
% PARTE 3
% ====================================
\part{Disegnare e Muovere (La Logica del Gioco)}

\section{Disegnare con i Pixel}

Per creare disegni o giochi, non usiamo solo pulsanti pronti, ma impariamo a colorare lo schermo punto per punto. Questi punti si chiamano \textbf{Pixel}.

\subsection{Gli strumenti per disegnare}

Per disegnare in C\# ci servono tre cose fondamentali:

\begin{enumerate}
    \item \textbf{PictureBox}: È la cornice o il "quadro" che mettiamo sulla nostra Form per far vedere i disegni.
    
    \item \textbf{Bitmap}: È il nostro "foglio digitale". Immaginalo come un foglio a quadretti trasparente grande quanto la PictureBox.
    
    \item \textbf{SetPixel}: È il comando che usiamo per colorare un singolo quadretto (pixel) in una posizione precisa (x, y) con un colore scelto.
\end{enumerate}

Esempio di codice:

\begin{lstlisting}[caption={Disegnare un pixel}]
// Creiamo un foglio digitale grande quanto 
// la nostra PictureBox
Bitmap bmp = new Bitmap(pictureBox1.Width, 
                        pictureBox1.Height);

// Coloriamo un pixel di rosso nelle 
// coordinate x=10 e y=20
bmp.SetPixel(10, 20, Color.Red);

// Diciamo alla PictureBox di mostrare il 
// foglio che abbiamo disegnato
pictureBox1.Image = bmp;
\end{lstlisting}

\subsection{I Cicli: Ripetere un'azione tante volte}

Prima di disegnare un quadrato completo, dobbiamo capire come dire 
al computer di ripetere un'azione molte volte. Per questo usiamo 
il \textbf{ciclo for}.

\subsubsection{Il ciclo for semplice}

Un ciclo for serve a contare da un numero all'altro:

\begin{lstlisting}[caption={Esempio di ciclo for}]
for (int i = 0; i < 10; i++)
{
    // Questo codice si ripete 10 volte
    // i vale: 0, poi 1, poi 2... fino a 9
}
\end{lstlisting}

\textbf{Spiegazione:}
\begin{itemize}
    \item \texttt{int i = 0} - Parte da 0
    \item \texttt{i < 10} - Continua finché i è minore di 10
    \item \texttt{i++} - Dopo ogni giro, aumenta i di 1
\end{itemize}

\subsubsection{Cicli annidati: La griglia}

Per colorare un quadrato, abbiamo bisogno di colorare tanti pixel 
in una griglia. Immagina una scacchiera: dobbiamo riempire tutte 
le caselle una per una.

Per farlo usiamo \textbf{due cicli, uno dentro l'altro}:

\begin{enumerate}
    \item Un ciclo che scorre le \textbf{colonne} (coordinate X da sinistra a destra)
    \item Un ciclo che scorre le \textbf{righe} (coordinate Y dall'alto in basso)
\end{enumerate}

\begin{lstlisting}[caption={Esempio di cicli annidati}]
// Ciclo esterno: scorre le colonne (asse X)
for (int x = 0; x < 10; x++)
{
    // Ciclo interno: scorre le righe (asse Y)
    for (int y = 0; y < 10; y++)
    {
        // Questo codice si esegue 10 x 10 = 100 volte!
        // Colora il pixel nella posizione (x, y)
        foglio.SetPixel(x, y, Color.Red);
    }
}
\end{lstlisting}

\textbf{Come funziona:}
\begin{itemize}
    \item Quando \texttt{x=0}, il ciclo interno colora tutti i punti 
          da \texttt{y=0} a \texttt{y=9} (una colonna verticale)
    \item Poi \texttt{x} diventa 1, e il ciclo interno riparte colorando 
          la seconda colonna
    \item E così via fino a \texttt{x=9}
\end{itemize}

Risultato: un quadrato di 10×10 pixel = 100 pixel colorati!

\begin{consiglio}
Pensa ai cicli annidati come a leggere un libro: 
\begin{itemize}
    \item Il ciclo esterno cambia \textbf{pagina} (colonna X)
    \item Il ciclo interno legge tutte le \textbf{righe} di quella pagina (Y)
\end{itemize}
\end{consiglio}

\subsection{Esercizio: Disegna un quadratino rosso}

\begin{esercizio}
\textbf{Obiettivo:} Colorare un piccolo quadrato di 10x10 pixel al centro dello schermo.
\end{esercizio}

\textbf{Soluzione:}

\begin{lstlisting}[caption={Disegnare un quadrato}]
Bitmap foglio = new Bitmap(pictureBox1.Width, 
                           pictureBox1.Height);

// Ciclo per la larghezza
for (int i = 50; i < 60; i++) 
{
    // Ciclo per l'altezza
    for (int j = 50; j < 60; j++) 
    {
        foglio.SetPixel(i, j, Color.Red);
    }
}

pictureBox1.Image = foglio;
\end{lstlisting}

% ====================================
\section{Il Timer: L'orologio del Programmatore}

Per far muovere qualcosa, dobbiamo ridisegnarlo tante volte in posizioni leggermente diverse, proprio come nei cartoni animati. Il \textbf{Timer} è lo strumento che dice al computer quando è il momento di fare un passo avanti.

\subsection{Come funziona il Timer?}

\begin{itemize}
    \item \textbf{Interval}: È la velocità del "battito". Si misura in millisecondi (ms). Se impostiamo 20, il timer farà un "tic" 50 volte al secondo.
    
    \item \textbf{Enabled}: Serve per accendere (\texttt{true}) o spegnere (\texttt{false}) il movimento.
    
    \item \textbf{Evento Tick}: È la funzione che viene eseguita a ogni "tic" dell'orologio.
\end{itemize}

\subsection{Come aggiungere il Timer al progetto}

Il Timer è uno strumento speciale: \textbf{non si vede sulla finestra}, 
ma appare in una zona chiamata "Component Tray" (vassoio dei componenti) 
sotto la Form.

\textbf{Procedura passo-passo:}

\begin{enumerate}
    \item Apri la \textbf{Toolbox} (la scatola degli attrezzi a sinistra).
    
    \item Cerca nella categoria \textbf{"Components"} oppure scrivi 
          "Timer" nella casella di ricerca.
    
    \item \textbf{Trascina il Timer} sulla tua Form. Non importa dove 
          lo lasci: apparirà automaticamente nella zona grigia sotto 
          la finestra (il Component Tray) e si chiamerà \texttt{timer1}.
    
    \item \textbf{Clicca sul Timer} nel Component Tray per selezionarlo.
    
    \item Vai nella finestra delle \textbf{Proprietà} e imposta:
    \begin{itemize}
        \item \textbf{Interval}: Scrivi \texttt{20} (significa 20 millisecondi, 
              cioè il Timer scatterà 50 volte al secondo)
        \item \textbf{Enabled}: Imposta su \texttt{True} per farlo partire 
              subito, oppure lascia \texttt{False} se vuoi attivarlo solo 
              quando premi un pulsante
    \end{itemize}
    
    \item Per creare l'evento Tick, fai \textbf{doppio clic sul Timer} 
          nel Component Tray. Visual Studio aprirà il codice e creerà 
          automaticamente la funzione:
          
          \texttt{private void timer1\_Tick(object sender, EventArgs e)}
          
    \item Ora sei pronto per scrivere il codice che si ripeterà a ogni "tic"!
\end{enumerate}

\begin{consiglio}
Se vuoi che il Timer parta solo quando premi un pulsante (ad esempio 
"Inizia Gioco"), lascia \texttt{Enabled = False} nelle proprietà. 
Poi, nel codice del pulsante, scrivi:

\texttt{timer1.Enabled = true;} // Accende il Timer

Per fermarlo, usa:

\texttt{timer1.Enabled = false;} // Spegne il Timer
\end{consiglio}


\subsection{La logica del movimento}

A ogni "tic" del Timer dobbiamo:

\begin{enumerate}
    \item \textbf{Cancellare} l'oggetto dalla vecchia posizione (colorandolo di bianco).
    
    \item \textbf{Aggiornare} la posizione (es. aggiungere 1 alla coordinata X).
    
    \item \textbf{Ridisegnare} l'oggetto nella nuova posizione.
\end{enumerate}

\subsection{Creiamo la funzione per disegnare un punto}

Prima di far muovere il punto, dobbiamo creare una funzione che sa come 
disegnarlo sullo schermo. Questa funzione farà tre cose:

\begin{enumerate}
    \item Cancella tutto lo schermo (riempie di bianco)
    \item Disegna il punto nella nuova posizione
    \item Mostra l'immagine aggiornata
\end{enumerate}

\subsubsection{Preparazione: Variabili globali}

Per prima cosa, dobbiamo dichiarare il foglio digitale come variabile 
globale nella classe Form:

\begin{lstlisting}[caption={Variabili globali per l'animazione}]
public partial class Form1 : Form
{
    // Variabili globali
    Bitmap foglio;
    int x = 10; // Posizione di partenza del punto
    
    public Form1()
    {
        InitializeComponent();
    }
    
    private void Form1_Load(object sender, EventArgs e)
    {
        // Creiamo il foglio grande quanto la PictureBox
        foglio = new Bitmap(pictureBox1.Width, 
                            pictureBox1.Height);
        
        // Riempiamo il foglio di bianco
        using (Graphics g = Graphics.FromImage(foglio))
        {
            g.Clear(Color.White);
        }
        
        // Mostriamo il foglio vuoto
        pictureBox1.Image = foglio;
    }
}
\end{lstlisting}

\subsubsection{La funzione disegnaPunto}

Ora creiamo la funzione che disegna il punto:

\begin{lstlisting}[caption={Funzione per disegnare un punto}]
private void disegnaPunto(int posX, int posY)
{
    // 1. Cancelliamo tutto (riempiamo di bianco)
    using (Graphics g = Graphics.FromImage(foglio))
    {
        g.Clear(Color.White);
    }
    
    // 2. Disegniamo il punto rosso nella nuova posizione
    // Facciamolo un po' più grande (3x3 pixel) per vederlo meglio
    for (int i = posX - 1; i <= posX + 1; i++)
    {
        for (int j = posY - 1; j <= posY + 1; j++)
        {
            // Controlla che non esca dai bordi
            if (i >= 0 && i < foglio.Width && 
                j >= 0 && j < foglio.Height)
            {
                foglio.SetPixel(i, j, Color.Red);
            }
        }
    }
    
    // 3. Mostriamo il foglio aggiornato
    pictureBox1.Image = foglio;
}
\end{lstlisting}

\textbf{Spiegazione del codice:}

\begin{itemize}
    \item \texttt{Graphics.Clear(Color.White)}: Cancella tutto riempiendo 
          di bianco. È più veloce che usare SetPixel su ogni punto!
    
    \item Il doppio ciclo \texttt{for}: Disegna un quadratino 3×3 invece 
          di un singolo pixel, così il punto si vede meglio.
    
    \item Il controllo \texttt{if}: Previene errori se il punto esce 
          dai bordi dell'immagine.
\end{itemize}

\begin{consiglio}
Se vuoi un punto più grande, puoi cambiare i cicli for. 
Ad esempio, per un punto 5×5:

\texttt{for (int i = posX - 2; i <= posX + 2; i++)}

Il numero che togli e aggiungi a \texttt{posX} decide la grandezza!
\end{consiglio}

\subsection{Esercizio: Il Punto che cammina}

\begin{esercizio}
\textbf{Obiettivo:} Far muovere un punto orizzontalmente da solo.
\end{esercizio}

\textbf{Soluzione:}

\subsubsection{Creiamo la funzione per disegnare}

Prima di far muovere il punto, dobbiamo creare una funzione che sa come disegnarlo:

\begin{lstlisting}[caption={Funzione per disegnare un punto}]
// Dichiariamo il foglio digitale come variabile globale
Bitmap foglio;

private void Form1_Load(object sender, EventArgs e)
{
    // Creiamo il foglio grande quanto la PictureBox
    foglio = new Bitmap(pictureBox1.Width, 
                        pictureBox1.Height);
}

private void disegnaPunto(int posX, int posY)
{
    // Cancelliamo tutto (riempiamo di bianco)
    using (Graphics g = Graphics.FromImage(foglio))
    {
        g.Clear(Color.White);
    }
    
    // Disegniamo il punto rosso nella nuova posizione
    foglio.SetPixel(posX, posY, Color.Red);
    
    // Mostriamo il foglio aggiornato
    pictureBox1.Image = foglio;
}
\end{lstlisting}

\begin{lstlisting}[caption={Punto in movimento}]
// Posizione di partenza
int x = 10; 

private void timer1_Tick(object sender, EventArgs e)
{
    // Spostiamo il punto di 2 pixel a ogni tic
    x = x + 2; 
    
    // Funzione che colora il pixel
    disegnaPunto(x, 50); 
}
\end{lstlisting}

\begin{attenzione}
\textbf{L'Errore più Comune!}

Guardate bene dove abbiamo dichiarato la variabile \texttt{int x = 10;}. L'abbiamo scritta \textbf{fuori} dalla funzione \texttt{timer1\_Tick}, all'inizio della classe Form.

\textbf{Perché?}

\textbf{Variabile FUORI (Globale/di Classe)}: La variabile nasce quando parte il programma e mantiene la sua memoria per tutto il tempo. Ogni volta che il Timer scatta, ritrova il valore precedente modificato.

\textbf{Variabile DENTRO (Locale)}: Se scriveste \texttt{int x = 10;} dentro le parentesi graffe del \texttt{timer1\_Tick}, la variabile verrebbe creata, impostata a 10, aumentata a 15 e poi distrutta subito dopo. Al prossimo scatto del Timer? Verrebbe creata di nuovo a 10. Il vostro oggetto sembrerebbe immobile!

\textbf{Regola d'oro:} Se un dato deve cambiare nel tempo e ricordarsi il valore precedente (come la posizione di un personaggio), deve essere dichiarato fuori dai metodi.
\end{attenzione}

% ====================================
\section{Gestire la Tastiera: Comandiamo noi!}

Vogliamo che il nostro quadratino si muova quando premiamo le frecce della tastiera? Per farlo usiamo l'evento \textbf{KeyDown}.

\subsection{Configurazione Iniziale}

Per far sì che la finestra "senta" i tasti della tastiera, dobbiamo 
attivare una proprietà speciale della Form chiamata \texttt{KeyPreview}.

\subsubsection{Metodo 1: Impostare KeyPreview nel Designer}

Questo è il metodo più semplice e visivo:

\begin{enumerate}
    \item \textbf{Clicca sulla Form} (la finestra principale, NON su un 
          controllo dentro di essa). Clicca su un punto vuoto della Form.
    
    \item Guarda la finestra delle \textbf{Proprietà} (di solito 
          in basso a destra). In alto nella finestra vedrai scritto 
          "Form1 System.Windows.Forms.Form".
    
    \item \textbf{Cerca la proprietà KeyPreview}. Puoi scorrere la lista 
          o digitare "KeyPreview" nella casella di ricerca in alto.
    
    \item Cambia il valore da \texttt{False} a \textbf{\texttt{True}} 
          usando il menu a tendina.
    
    \item Fatto! Ora la Form intercetterà tutti i tasti premuti prima 
          che arrivino ai controlli.
\end{enumerate}

\subsubsection{Metodo 2: Impostare KeyPreview nel codice}

In alternativa, puoi attivare KeyPreview nel costruttore della Form:

\begin{lstlisting}[caption={Attivare KeyPreview nel costruttore}]
public partial class Form1 : Form
{
    public Form1()
    {
        InitializeComponent();
        
        // Attiva la lettura della tastiera
        this.KeyPreview = true;
    }
}
\end{lstlisting}

\textbf{Nota:} Il costruttore è il metodo \texttt{Form1()} che viene 
eseguito quando crei la finestra. \texttt{this} si riferisce alla Form 
stessa.

\subsubsection{Creare l'evento KeyDown}

Dopo aver attivato KeyPreview, devi creare l'evento che gestisce 
i tasti premuti:

\begin{enumerate}
    \item \textbf{Seleziona la Form} (clicca su un punto vuoto).
    
    \item Nella finestra delle \textbf{Proprietà}, clicca sull'icona 
          del fulmine ⚡ (Events/Eventi) in alto. Questo mostra tutti 
          gli eventi disponibili.
    
    \item \textbf{Cerca "KeyDown"} nella lista degli eventi.
    
    \item \textbf{Fai doppio clic} sulla riga vuota accanto a "KeyDown". 
          Visual Studio creerà automaticamente la funzione:
          
          \texttt{private void Form1\_KeyDown(object sender, KeyEventArgs e)}
          
    \item Ora sei pronto per scrivere il codice che reagisce ai tasti!
\end{enumerate}

\subsubsection{Verifica che funzioni}

Per testare che KeyPreview sia attivo, prova questo codice nell'evento 
KeyDown:

\begin{lstlisting}[caption={Test del KeyDown}]
private void Form1_KeyDown(object sender, KeyEventArgs e)
{
    // Mostra quale tasto hai premuto
    MessageBox.Show("Hai premuto: " + e.KeyCode.ToString());
}
\end{lstlisting}

Se premi F5 per avviare il programma e poi premi una freccia, 
dovresti vedere una finestra che dice "Hai premuto: Up" (o Down, 
Left, Right).

\begin{attenzione}
\textbf{Problema comune: KeyDown non funziona!}

Se premi i tasti e non succede nulla, controlla:

\begin{enumerate}
    \item \textbf{KeyPreview è davvero True?} Controlla nelle proprietà 
          della Form.
    
    \item \textbf{Hai creato l'evento sulla Form giusta?} Assicurati 
          di aver cliccato sulla Form (non su un Button o TextBox) 
          prima di creare l'evento.
    
    \item \textbf{Hai altri controlli che "catturano" i tasti?} 
          Se hai un Button selezionato, la freccia non arriverà 
          alla Form. Clicca sulla PictureBox o su un'area vuota 
          mentre testi.
\end{enumerate}
\end{attenzione}

\begin{consiglio}
\textbf{KeyPreview: Come funziona?}

Normalmente, quando premi un tasto, va direttamente al controllo 
che è "attivo" (per esempio, se stai scrivendo in una TextBox, 
i tasti vanno lì).

Con \texttt{KeyPreview = true}, diciamo al computer: 
"Prima di dare il tasto al controllo attivo, fallo vedere alla Form!". 

È come un guardiano che controlla tutto prima di lasciare passare. 
Questo ci permette di catturare i tasti freccia per controllare 
il nostro gioco anche se ci sono altri controlli sulla finestra.
\end{consiglio}

\subsection{Riconoscere i tasti}

Usiamo un comando chiamato \texttt{switch} che serve a scegliere cosa fare in base al tasto premuto:

\begin{itemize}
    \item \texttt{Keys.Up}: Freccia Su (diminuiamo la Y).
    \item \texttt{Keys.Down}: Freccia Giù (aumentiamo la Y).
    \item \texttt{Keys.Left}: Freccia Sinistra (diminuiamo la X).
    \item \texttt{Keys.Right}: Freccia Destra (aumentiamo la X).
\end{itemize}

\subsection{Preparazione: Variabili e funzione di disegno}

Per controllare il pixel con la tastiera, abbiamo bisogno di tenere 
traccia della sua posizione e di una funzione per ridisegnarlo ogni 
volta che si muove.

\subsubsection{Variabili globali per la posizione}

Dichiara queste variabili all'inizio della classe Form:

\begin{lstlisting}[caption={Variabili globali per controllo tastiera}]
public partial class Form1 : Form
{
    // Variabili globali
    Bitmap foglio;
    int x = 100; // Posizione iniziale X
    int y = 100; // Posizione iniziale Y
    
    public Form1()
    {
        InitializeComponent();
        
        // IMPORTANTE: Attiva la lettura della tastiera!
        this.KeyPreview = true;
    }
    
    private void Form1_Load(object sender, EventArgs e)
    {
        // Creiamo il foglio
        foglio = new Bitmap(pictureBox1.Width, 
                            pictureBox1.Height);
        
        // Riempiamo di bianco
        using (Graphics g = Graphics.FromImage(foglio))
        {
            g.Clear(Color.White);
        }
        
        // Disegna il punto nella posizione iniziale
        DisegnaPunto();
    }
}
\end{lstlisting}

\subsubsection{La funzione DisegnaPunto}

Questa funzione ridisegna tutto lo schermo con il punto nella posizione 
corrente:

\begin{lstlisting}[caption={Funzione DisegnaPunto per controllo tastiera}]
private void DisegnaPunto()
{
    // 1. Cancelliamo tutto lo schermo
    using (Graphics g = Graphics.FromImage(foglio))
    {
        g.Clear(Color.White);
    }
    
    // 2. Disegniamo il punto (5x5 pixel per vederlo meglio)
    for (int i = x - 2; i <= x + 2; i++)
    {
        for (int j = y - 2; j <= y + 2; j++)
        {
            // Controlla che non esca dai bordi
            if (i >= 0 && i < foglio.Width && 
                j >= 0 && j < foglio.Height)
            {
                foglio.SetPixel(i, j, Color.Blue);
            }
        }
    }
    
    // 3. Aggiorna la PictureBox
    pictureBox1.Image = foglio;
    pictureBox1.Refresh(); // Forza l'aggiornamento immediato
}
\end{lstlisting}

\begin{attenzione}
\textbf{Differenza tra disegnaPunto() e DisegnaPunto()}

Nota che questa funzione si chiama \texttt{DisegnaPunto()} con la D 
maiuscola, mentre quella dell'esercizio precedente era \texttt{disegnaPunto()}.

\textbf{Perché sono diverse?}

\begin{itemize}
    \item \texttt{disegnaPunto(posX, posY)}: Prende due parametri 
          (coordinate) ed è usata dal Timer che calcola continuamente 
          nuove posizioni.
    
    \item \texttt{DisegnaPunto()}: Non prende parametri perché usa 
          direttamente le variabili globali \texttt{x} e \texttt{y} 
          che vengono modificate dal KeyDown.
\end{itemize}

Sono due approcci diversi per lo stesso scopo: disegnare un punto 
che si muove!
\end{attenzione}

\begin{consiglio}
\textbf{Quando usare quale?}

\begin{itemize}
    \item Usa \texttt{disegnaPunto(x, y)} quando il movimento è 
          \textbf{automatico} (Timer) e vuoi più flessibilità.
    
    \item Usa \texttt{DisegnaPunto()} quando il movimento è 
          \textbf{manuale} (tastiera) e le coordinate sono sempre 
          nelle variabili globali.
\end{itemize}
\end{consiglio}

\subsection{Esercizio: Pilota il tuo pixel}

\begin{esercizio}
\textbf{Obiettivo:} Muovere un pixel sullo schermo usando le frecce della tastiera.
\end{esercizio}

\textbf{Soluzione:}

\begin{lstlisting}[caption={Controllo da tastiera}]
private void Form1_KeyDown(object sender, KeyEventArgs e)
{
    switch(e.KeyCode)
    {
        case Keys.Up:    
            y -= 5; // Va su
            break; 
            
        case Keys.Down:  
            y += 5; // Va giu
            break; 
            
        case Keys.Left:  
            x -= 5; // Va a sinistra
            break; 
            
        case Keys.Right: 
            x += 5; // Va a destra
            break; 
    }
    
    // Controlliamo che non esca dallo schermo
    if (x < 0) x = 0;
    if (y < 0) y = 0;
    
    // Ridisegna nella nuova posizione
    DisegnaPunto(); 
}
\end{lstlisting}

\subsection{Cosa abbiamo imparato in questa parte}

\begin{itemize}
    \item Usiamo la \textbf{Bitmap} come un foglio e \textbf{SetPixel} come un pennello.
    
    \item Il \textbf{Timer} crea le animazioni ripetendo azioni a intervalli regolari.
    
    \item Con \textbf{KeyDown} possiamo dare comandi al programma usando la tastiera.
\end{itemize}

\newpage

% ====================================
% PARTE 4
% ====================================
\part{Il Progetto Finale (Quadratini e Rimbalzi)}

\section{Prima di calcolare i rimbalzi: Com'è fatto il nostro Quadratino?}

Per gestire le collisioni nel prossimo capitolo, useremo delle proprietà specifiche. Assicuriamoci che la vostra classe \texttt{Quadratino} abbia tutte le informazioni necessarie: posizione (x, y), velocità (vx, vy) e grandezza (dimensione).

Ecco come deve apparire il codice della vostra classe per funzionare con gli esempi successivi:

\begin{lstlisting}[caption={Classe Quadratino completa}]
public class Quadratino
{
    // 1. PROPRIETA' (Le caratteristiche)
    public int x;          // Posizione orizzontale
    public int y;          // Posizione verticale
    public int vx;         // Velocita' orizzontale
    public int vy;         // Velocita' verticale
    public int dimensione; // Grandezza del lato
    public Color colore;   // Colore del quadrato

    // 2. COSTRUTTORE (Come nasce l'oggetto)
    // Ci permette di creare quadratini diversi
    public Quadratino(int startX, int startY, 
                      int velX, int velY, 
                      int dim, Color c)
    {
        x = startX;
        y = startY;
        vx = velX;
        vy = velY;
        dimensione = dim;
        colore = c;
    }
}
\end{lstlisting}

\textit{Ora che abbiamo definito \texttt{x}, \texttt{y} e \texttt{dimensione}, possiamo usare la matematica per capire quando toccano i bordi!}

% ====================================
\section{Il ricalcolo della posizione}

Il ricalcolo della posizione di un oggetto a ogni "battito" del timer segue una logica precisa che permette di creare l'illusione del movimento. Immagina che il Timer sia un orologio che, a ogni tick, dà il via a una serie di azioni.

\subsection{La sequenza delle operazioni}

All'interno dell'evento \texttt{timer1\_Tick}, il programma esegue questi quattro compiti in ordine:

\begin{enumerate}
    \item \textbf{Cancella}: Il quadratino viene cancellato dalla sua posizione attuale (colorando i pixel di bianco).
    
    \item \textbf{Sposta}: Viene calcolata la nuova posizione matematica.
    
    \item \textbf{Controlla}: Il computer verifica se il quadratino ha toccato i bordi della finestra o un ostacolo.
    
    \item \textbf{Disegna}: Il quadratino viene colorato nella nuova posizione.
\end{enumerate}

\subsection{La matematica del movimento (Sposta)}

Per muovere l'oggetto, sommiamo la sua velocità alla sua posizione attuale:

\begin{itemize}
    \item Nuova X = Posizione X precedente + Velocità Orizzontale (vx).
    \item Nuova Y = Posizione Y precedente + Velocità Verticale (vy).
\end{itemize}

Nel codice, questo si scrive in modo molto semplice:

\begin{lstlisting}
q.x = q.x + q.vx; 
q.y = q.y + q.vy;
\end{lstlisting}

\subsection{Gestire i rimbalzi (Controlla)}

Dopo aver calcolato la nuova posizione, il programma deve assicurarsi che l'oggetto non esca dallo schermo. Se il quadratino tocca un bordo, la sua velocità viene invertita:

\begin{itemize}
    \item \textbf{Rimbalzo a destra o sinistra}: Se \texttt{q.x} supera i limiti della larghezza, la velocità \texttt{vx} cambia segno (\texttt{q.vx = -q.vx}).
    
    \item \textbf{Rimbalzo in alto o in basso}: Se \texttt{q.y} supera i limiti dell'altezza, la velocità \texttt{vy} cambia segno (\texttt{q.vy = -q.vy}).
\end{itemize}

Inoltre, viene chiamata la funzione \texttt{controllaCollisioneOstacoli(q, o1)} per vedere se il quadratino ha colpito un muro o un blocco grigio all'interno della finestra.

\subsection{Esempio di codice riassuntivo}

\begin{lstlisting}[caption={Funzione di ricalcolo posizione}]
public Quadratino ricalcolaPosizione(Quadratino q)
{
    // 1. Muovi l'oggetto
    q.x = q.x + q.vx;
    q.y = q.y + q.vy;

    // 2. Controlla se sbatte contro i bordi 
    //    e inverti la marcia
    if (q.x - q.dimensione / 2 <= 0 || 
        q.x + q.dimensione / 2 >= pictureBox1.Width)
    {
        // Inverte direzione orizzontale
        q.vx = -q.vx; 
    }

    if (q.y - q.dimensione / 2 <= 0 || 
        q.y + q.dimensione / 2 >= pictureBox1.Height)
    {
        // Inverte direzione verticale
        q.vy = -q.vy; 
    }

    // 3. Controlla se sbatte contro l'ostacolo
    controllaCollisioneOstacoli(q, o1);

    return q;
}
\end{lstlisting}

\section{Le Funzioni per Disegnare i Quadratini}

Prima di mettere tutto nel Timer, dobbiamo creare le funzioni che sanno 
disegnare e cancellare i nostri quadratini sullo schermo.

\subsection{Dichiarare il foglio digitale}

Per prima cosa, dobbiamo creare una variabile \textbf{globale} (cioè 
che esiste per tutto il programma) per il nostro foglio Bitmap:

\begin{lstlisting}[caption={Variabile globale nella classe Form}]
public partial class Form1 : Form
{
    // Variabili globali
    Bitmap foglio;
    Quadratino q1;
    Ostacolo o1;
    
    public Form1()
    {
        InitializeComponent();
    }
    
    private void Form1_Load(object sender, EventArgs e)
    {
        // Creiamo il foglio grande quanto la PictureBox
        foglio = new Bitmap(pictureBox1.Width, 
                            pictureBox1.Height);
        
        // Creiamo il quadratino
        q1 = new Quadratino(100, 100, 3, 2, 20, Color.Red);
        
        // Avviamo il timer
        timer1.Enabled = true;
    }
}
\end{lstlisting}

\subsection{La funzione disegnaQuadrato}

Questa funzione colora tutti i pixel del quadratino nella sua posizione attuale:

\begin{lstlisting}[caption={Funzione per disegnare un quadratino}]
private void disegnaQuadrato(Quadratino q)
{
    // Calcoliamo i bordi del quadrato
    int sinistra = q.x - q.dimensione / 2;
    int destra = q.x + q.dimensione / 2;
    int alto = q.y - q.dimensione / 2;
    int basso = q.y + q.dimensione / 2;
    
    // Disegna pixel per pixel
    for (int i = sinistra; i <= destra; i++)
    {
        for (int j = alto; j <= basso; j++)
        {
            // Controlla che non esca dai bordi dell'immagine
            if (i >= 0 && i < foglio.Width && 
                j >= 0 && j < foglio.Height)
            {
                foglio.SetPixel(i, j, q.colore);
            }
        }
    }
    
    // Aggiorna la PictureBox per mostrare le modifiche
    pictureBox1.Image = foglio;
}
\end{lstlisting}

\subsection{La funzione cancellaQuadrato}

Questa funzione "cancella" il quadratino colorando i suoi pixel di bianco:

\begin{lstlisting}[caption={Funzione per cancellare un quadratino}]
private void cancellaQuadrato(Quadratino q)
{
    // Calcoliamo i bordi del quadrato
    int sinistra = q.x - q.dimensione / 2;
    int destra = q.x + q.dimensione / 2;
    int alto = q.y - q.dimensione / 2;
    int basso = q.y + q.dimensione / 2;
    
    // Cancella pixel per pixel (colora di bianco)
    for (int i = sinistra; i <= destra; i++)
    {
        for (int j = alto; j <= basso; j++)
        {
            // Controlla che non esca dai bordi
            if (i >= 0 && i < foglio.Width && 
                j >= 0 && j < foglio.Height)
            {
                foglio.SetPixel(i, j, Color.White);
            }
        }
    }
    // NON serve pictureBox1.Image = foglio qui,
    // perche' lo faremo dopo aver ridisegnato
}
\end{lstlisting}

\begin{attenzione}
\textbf{Perché cancellaQuadrato non aggiorna subito la PictureBox?}

Nota che nella funzione \texttt{cancellaQuadrato} non abbiamo scritto 
\texttt{pictureBox1.Image = foglio} alla fine.

\textbf{Motivo:} Nel Timer, facciamo questa sequenza:
\begin{enumerate}
    \item Cancelliamo il quadratino (coloriamo di bianco)
    \item Calcoliamo la nuova posizione
    \item Ridisegniamo il quadratino (coloriamo del suo colore)
    \item SOLO ALLA FINE aggiorniamo la PictureBox
\end{enumerate}

Se aggiornassimo la PictureBox dopo ogni operazione, vedremmo uno 
"sfarfallio" fastidioso! Invece, preparando tutto sul foglio e 
mostrando l'immagine solo alla fine, il movimento è fluido.
\end{attenzione}

\subsection{Esempio completo nel Timer}

Ecco come usare tutte queste funzioni insieme:

\begin{lstlisting}[caption={Timer completo con le funzioni}]
private void timer1_Tick(object sender, EventArgs e)
{
    // 1. Cancella il quadratino dalla vecchia posizione
    cancellaQuadrato(q1);
    
    // 2. Ricalcola la posizione e gestisci i rimbalzi
    q1 = ricalcolaPosizione(q1);
    
    // 3. Ridisegna l'ostacolo (se esiste)
    if (o1 != null)
        disegnaOstacolo(o1);
    
    // 4. Disegna il quadratino nella nuova posizione
    disegnaQuadrato(q1);
    
    // La PictureBox si aggiorna automaticamente 
    // nella funzione disegnaQuadrato
}
\end{lstlisting}


% ====================================
\section{Gli Ostacoli e le Collisioni}

Per far rimbalzare un quadratino contro un ostacolo, dobbiamo usare la logica del "confronto dei bordi". Immagina che il quadratino e l'ostacolo siano due scatole: dobbiamo capire se queste scatole si stanno sovrapponendo.

\subsection{Creiamo l'Ostacolo}

Prima di tutto, definiamo cos'è un ostacolo. Un ostacolo è un rettangolo che ha due punti fissi: l'angolo in alto a sinistra (x0, y0) e l'angolo in basso a destra (x1, y1).

\subsubsection{Il Codice della Classe Ostacolo}

Ora che sappiamo cos'è un ostacolo concettualmente, scriviamo il codice 
per crearlo nel nostro programma:

\begin{lstlisting}[caption={Classe Ostacolo}]
public class Ostacolo
{
    // Le coordinate del rettangolo
    public int x0, y0; // Angolo in alto a sinistra
    public int x1, y1; // Angolo in basso a destra
    public Color colore; // Il colore dell'ostacolo
    
    // Il costruttore: come creare un nuovo ostacolo
    public Ostacolo(int inizioX, int inizioY, 
                    int fineX, int fineY)
    {
        x0 = inizioX;
        y0 = inizioY;
        x1 = fineX;
        y1 = fineY;
        colore = Color.Gray;
    }
}
\end{lstlisting}

\textbf{Come usare questa classe:}

Nell'evento \texttt{Form1\_Load}, puoi creare un ostacolo così:

\begin{lstlisting}[caption={Creare un ostacolo}]
// Creiamo un ostacolo al centro dello schermo
Ostacolo o1 = new Ostacolo(200, 200, 300, 300);
\end{lstlisting}

Questo crea un rettangolo grigio che va da (200,200) a (300,300), 
quindi largo e alto 100 pixel.

\subsubsection{Disegnare l'Ostacolo sullo schermo}

Ora che abbiamo creato l'ostacolo, dobbiamo farlo vedere! Aggiungiamo 
una funzione per disegnarlo:

\begin{lstlisting}[caption={Funzione per disegnare l'ostacolo}]
private void disegnaOstacolo(Ostacolo o)
{
    // Disegna un rettangolo pieno
    for (int i = o.x0; i <= o.x1; i++)
    {
        for (int j = o.y0; j <= o.y1; j++)
        {
            // Controlla che non esca dai bordi
            if (i >= 0 && i < foglio.Width && 
                j >= 0 && j < foglio.Height)
            {
                foglio.SetPixel(i, j, o.colore);
            }
        }
    }
    pictureBox1.Image = foglio;
}
\end{lstlisting}

\begin{consiglio}
Chiama \texttt{disegnaOstacolo(o1)} nell'evento \texttt{Form1\_Load} 
dopo aver creato l'ostacolo, così sarà visibile fin dall'inizio del programma!

Puoi anche chiamarla nel Timer prima di disegnare i quadratini, così 
l'ostacolo sarà sempre visibile anche quando i quadratini si muovono 
sopra di esso.
\end{consiglio}

\subsection{La logica del "Tocco" (Collisione)}

Per capire se il quadratino colpisce l'ostacolo, il computer controlla due cose:

\begin{enumerate}
    \item \textbf{Controllo Orizzontale}: Il quadratino si trova alla stessa "altezza" dell'ostacolo? Se sì, sta toccando il bordo destro o sinistro?
    
    \item \textbf{Controllo Verticale}: Il quadratino si trova nella stessa "corsia" dell'ostacolo? Se sì, sta toccando il bordo superiore o inferiore?
\end{enumerate}

\subsection{Cosa succede quando sbatte?}

Quando il computer capisce che c'è un tocco, dobbiamo fare due azioni immediate:

\begin{itemize}
    \item \textbf{Sposta}: Spostiamo il quadratino appena fuori dall'ostacolo (per evitare che rimanga "incastrato" dentro).
    
    \item \textbf{Inverti}: Cambiamo la direzione della velocità. Se stava andando a destra (vx positivo), lo facciamo andare a sinistra (vx diventa negativo).
\end{itemize}

\subsection{Il Codice della Collisione (Semplificato)}

Ecco come appare la funzione che controlla se il quadratino \texttt{q} sbatte contro l'ostacolo \texttt{o}:

\begin{lstlisting}[caption={Controllo collisioni con ostacoli}]
public void controllaCollisioneOstacoli(
    Quadratino q, Ostacolo o)
{
    // 1. Controlliamo se il quadratino e' 
    //    all'altezza giusta per colpire i lati
    if (q.y + q.dimensione / 2 >= o.y0 && 
        q.y - q.dimensione / 2 <= o.y1)
    {
        // Se sbatte contro la faccia sinistra 
        // dell'ostacolo mentre va a destra
        if (q.x + q.dimensione / 2 >= o.x0 && 
            q.vx > 0 && 
            q.x + q.dimensione / 2 <= o.x0 + q.vx)
        {
            q.vx = -q.vx; // Rimbalza!
        }
        
        // Se sbatte contro la faccia destra 
        // dell'ostacolo mentre va a sinistra
        if (q.x - q.dimensione / 2 <= o.x1 && 
            q.vx < 0 && 
            q.x - q.dimensione / 2 >= o.x1 + q.vx)
        {
            q.vx = -q.vx; // Rimbalza!
        }
    }
}
\end{lstlisting}

% ====================================
\section{Mettere tutto insieme: Il Ciclo di Movimento}

Ora che sappiamo come gestire i rimbalzi, dobbiamo inserire tutto nel Timer, che è il motore del nostro programma.

Ogni volta che il timer fa "Tick", il programma segue questi 4 passi:

\begin{enumerate}
    \item \textbf{Cancella}: Colora di bianco la vecchia posizione del quadratino.
    
    \item \textbf{Sposta}: Calcola la nuova posizione aggiungendo la velocità (es: \texttt{x = x + vx}).
    
    \item \textbf{Controlla}: Verifica se il quadratino ha toccato i bordi della finestra o l'ostacolo. Se sì, cambia la velocità.
    
    \item \textbf{Disegna}: Colora il quadratino nella sua nuova posizione.
\end{enumerate}

\subsection{Esercizio: Il Muro Grigio}

\begin{esercizio}
\textbf{Obiettivo:} Aggiungi un rettangolo grigio al centro dello schermo e fai in modo che il tuo quadratino rosso ci rimbalzi contro.

\textbf{Istruzioni:}
\begin{enumerate}
    \item Crea un oggetto \texttt{Ostacolo} chiamato \texttt{o1} nel \texttt{Load} della Form e dagli delle coordinate (es: x0=200, y0=200, x1=300, y1=300).
    
    \item Nel \texttt{timer1\_Tick}, dopo aver aggiornato la posizione del quadratino, chiama la funzione \texttt{controllaCollisioneOstacoli(q1, o1)}.
\end{enumerate}
\end{esercizio}

\textbf{Soluzione (Logica):}

\begin{lstlisting}[caption={Ciclo completo nel Timer}]
// Dentro il Timer
cancellaQuadrato(q1);  // Cancella vecchio
q1.x += q1.vx;         // Muovi
q1.y += q1.vy;

// Controlla se sbatte contro il muro
controllaCollisioneOstacoli(q1, o1); 

disegnaQuadrato(q1);   // Disegna nuovo
\end{lstlisting}

\subsection{Cosa abbiamo imparato}

\begin{itemize}
    \item Le collisioni si gestiscono confrontando le coordinate dei bordi (X e Y).
    
    \item Per far rimbalzare un oggetto, basta moltiplicare la sua velocità per -1 (es: \texttt{vx = -vx}).
    
    \item Il Timer coordina tutto: cancella, muove, controlla e ridisegna.
\end{itemize}

% ====================================
\section{Gestire più quadratini contemporaneamente}

Gestire più quadratini contemporaneamente è un passaggio fondamentale per rendere le tue applicazioni più dinamiche e interessanti. Per farlo, utilizziamo la programmazione a oggetti, che ci permette di creare molteplici copie (istanze) partendo dallo stesso stampo (classe).

\subsection{Creare le "Istanze" dei Quadratini}

Invece di creare un solo oggetto, dichiariamo diversi quadratini all'interno della classe della nostra finestra (Form):

\begin{lstlisting}
Quadratino q1 = new Quadratino();
Quadratino q2 = new Quadratino();
Quadratino q3 = new Quadratino();
\end{lstlisting}

\subsection{Dare caratteristiche diverse a ognuno}

Perché i quadratini non si sovrappongano e si muovano in modo unico, dobbiamo assegnare a ciascuno valori iniziali differenti nell'evento \texttt{Load} della Form:

\begin{itemize}
    \item \textbf{Posizione}: \texttt{q1} potrebbe partire in alto a sinistra (100, 100), mentre \texttt{q2} al centro (300, 200).
    
    \item \textbf{Velocità}: Assegnando velocità diverse (es. \texttt{q1.vx = 2} e \texttt{q2.vx = -1}), i quadratini si muoveranno a ritmi differenti e in direzioni opposte.
    
    \item \textbf{Aspetto}: Puoi cambiare la dimensione e il colore per distinguerli facilmente (es. uno rosso, uno verde e uno blu).
\end{itemize}

\subsection{Gestire il movimento nel Timer}

Il segreto per farli muovere tutti insieme "nello stesso momento" è scrivere le istruzioni per ogni quadratino all'interno dell'evento \texttt{Tick} del Timer.

Il computer è così veloce che eseguirà questi comandi in sequenza per ogni oggetto, dandoci l'illusione che si muovano contemporaneamente:

\begin{enumerate}
    \item \textbf{Cancella tutti}: \texttt{cancellaQuadrato(q1);}, \texttt{cancellaQuadrato(q2);}, ecc.
    
    \item \textbf{Sposta tutti}: Ricalcoli la posizione per ognuno (\texttt{q1 = ricalcolaPosizione(q1);}, ecc.).
    
    \item \textbf{Disegna tutti}: Li mostri nella nuova posizione (\texttt{disegnaQuadrato(q1);}, ecc.).
\end{enumerate}

\subsection{Il trucco degli esperti: Usare le Liste}

Se i quadratini diventano tanti (ad esempio 10 o 100), invece di scrivere i nomi uno per uno, usiamo una Lista (\texttt{List<Quadratino>}).

Con una lista, puoi usare un ciclo \texttt{foreach} per dire al computer: "Per ogni quadratino che trovi nella mia lista, cancellalo, muovilo e ridisegnalo". Questo rende il codice molto più corto e ordinato.

\subsection{Esercizio: "La Danza dei Quadratini"}

\begin{esercizio}
\textbf{Obiettivo:} Gestire tre quadratini che rimbalzano con colori e velocità diverse.
\end{esercizio}

\textbf{Soluzione (Logica nel Timer):}

\begin{lstlisting}[caption={Gestione multipla nel Timer}]
private void timer1_Tick(object sender, EventArgs e)
{
    // 1. Fase di cancellazione 
    //    (pulizia vecchia posizione)
    cancellaQuadrato(q1);
    cancellaQuadrato(q2);
    cancellaQuadrato(q3);

    // 2. Fase di ricalcolo 
    //    (aggiornamento velocita' e rimbalzi)
    q1 = ricalcolaPosizione(q1);
    q2 = ricalcolaPosizione(q2);
    q3 = ricalcolaPosizione(q3);

    // 3. Fase di disegno 
    //    (mostra nuova posizione)
    disegnaQuadrato(q1);
    disegnaQuadrato(q2);
    disegnaQuadrato(q3);
}
\end{lstlisting}

\subsection{Cosa abbiamo imparato}

\begin{itemize}
    \item Ogni quadratino è un oggetto indipendente con le sue proprietà (x, y, velocità, colore).
    
    \item Il Timer gestisce tutti i quadratini in sequenza a ogni suo "battito".
    
    \item Le Liste sono lo strumento migliore per gestire grandi quantità di oggetti senza fatica.
\end{itemize}

% ====================================
\section{Il Trucco degli Esperti: Usare le Liste}

Finora abbiamo gestito i quadratini uno per uno (\texttt{q1}, \texttt{q2}, 
\texttt{q3}). Ma cosa succede se ne vogliamo 10? O 100? Scrivere 
\texttt{disegnaQuadrato(q1); disegnaQuadrato(q2); ... disegnaQuadrato(q100);} 
sarebbe un incubo!

La soluzione è usare una \textbf{Lista}.

\subsection{Cos'è una List<Quadratino>?}

Una \texttt{List<Quadratino>} è una "scatola" che può contenere tanti 
oggetti di tipo Quadratino. Possiamo aggiungere, togliere e scorrere 
tutti gli elementi facilmente.

\subsection{Creare e riempire la lista}

Ecco come dichiarare e riempire una lista di quadratini:

\begin{lstlisting}[caption={Lista di quadratini}]
public partial class Form1 : Form
{
    // Variabili globali
    Bitmap foglio;
    List<Quadratino> quadratini; // La nostra lista!
    Ostacolo o1;
    
    public Form1()
    {
        InitializeComponent();
    }
    
    private void Form1_Load(object sender, EventArgs e)
    {
        // Creiamo il foglio
        foglio = new Bitmap(pictureBox1.Width, 
                            pictureBox1.Height);
        
        // Creiamo la lista vuota
        quadratini = new List<Quadratino>();
        
        // Aggiungiamo 5 quadratini con proprietà casuali
        Random rnd = new Random();
        for (int i = 0; i < 5; i++)
        {
            // Posizione casuale
            int posX = rnd.Next(50, pictureBox1.Width - 50);
            int posY = rnd.Next(50, pictureBox1.Height - 50);
            
            // Velocità casuale (tra -3 e +3)
            int velX = rnd.Next(-3, 4);
            int velY = rnd.Next(-3, 4);
            
            // Colori diversi
            Color[] colori = { Color.Red, Color.Blue, 
                               Color.Green, Color.Orange, 
                               Color.Purple };
            
            // Creiamo e aggiungiamo il quadratino
            Quadratino q = new Quadratino(posX, posY, 
                                           velX, velY, 
                                           20, colori[i]);
            quadratini.Add(q);
        }
        
        // Creiamo l'ostacolo
        o1 = new Ostacolo(200, 200, 300, 300);
        
        // Avviamo il timer
        timer1.Enabled = true;
    }
}
\end{lstlisting}

\subsection{Il ciclo foreach: Scorrere la lista}

Invece di scrivere \texttt{disegnaQuadrato(q1); disegnaQuadrato(q2);} 
per ogni quadratino, usiamo il \textbf{ciclo foreach}:

\begin{lstlisting}[caption={Ciclo foreach}]
foreach (Quadratino q in quadratini)
{
    // Questo codice si ripete per OGNI quadratino 
    // nella lista automaticamente!
    disegnaQuadrato(q);
}
\end{lstlisting}

\textbf{Come funziona:}
\begin{itemize}
    \item \texttt{foreach}: Significa "per ogni"
    \item \texttt{Quadratino q}: A ogni giro, \texttt{q} diventa uno 
          dei quadratini della lista
    \item \texttt{in quadratini}: Indica da quale lista prendere gli elementi
\end{itemize}

È come dire: "Per ogni quadratino che trovi nella mia lista, 
fai questa operazione".

\subsection{Il Timer con le Liste}

Ecco come diventa il Timer usando le liste:

\begin{lstlisting}[caption={Timer con List e foreach}]
private void timer1_Tick(object sender, EventArgs e)
{
    // 1. FASE CANCELLAZIONE
    foreach (Quadratino q in quadratini)
    {
        cancellaQuadrato(q);
    }
    
    // 2. FASE RICALCOLO
    // Attenzione: non possiamo modificare la lista 
    // durante il foreach, quindi usiamo un ciclo for
    for (int i = 0; i < quadratini.Count; i++)
    {
        quadratini[i] = ricalcolaPosizione(quadratini[i]);
        controllaCollisioneOstacoli(quadratini[i], o1);
    }
    
    // 3. FASE DISEGNO
    // Ridisegna l'ostacolo
    if (o1 != null)
        disegnaOstacolo(o1);
    
    // Ridisegna tutti i quadratini
    foreach (Quadratino q in quadratini)
    {
        disegnaQuadrato(q);
    }
}
\end{lstlisting}

\begin{attenzione}
\textbf{Perché usiamo for invece di foreach nella fase ricalcolo?}

Nella fase di ricalcolo scriviamo:
\texttt{quadratini[i] = ricalcolaPosizione(quadratini[i]);}

Questo \textbf{modifica} l'oggetto nella lista. Con \texttt{foreach} 
non possiamo farlo perché \texttt{q} è solo una "copia temporanea".

Con il ciclo \texttt{for} accediamo direttamente alla lista con 
\texttt{quadratini[i]} e possiamo modificarla.

\textbf{Regola pratica:}
\begin{itemize}
    \item Usa \texttt{foreach} quando vuoi solo LEGGERE (cancellare, 
          disegnare)
    \item Usa \texttt{for} quando vuoi MODIFICARE (ricalcolare posizione)
\end{itemize}
\end{attenzione}

\subsection{Esercizio Finale: Il Rimbalzo Multiplo}

\begin{esercizio}
\textbf{Obiettivo:} Creare un programma con 10 quadratini colorati 
che rimbalzano contro i bordi e contro un ostacolo centrale.

\textbf{Istruzioni:}
\begin{enumerate}
    \item Crea un nuovo progetto Windows Forms.
    
    \item Aggiungi una PictureBox grande (es. 600×400) e un Timer.
    
    \item Copia le classi \texttt{Quadratino} e \texttt{Ostacolo} 
          nel tuo progetto.
    
    \item Copia le funzioni \texttt{disegnaQuadrato}, 
          \texttt{cancellaQuadrato}, \texttt{disegnaOstacolo} e 
          \texttt{ricalcolaPosizione}.
    
    \item Nel \texttt{Form1\_Load}:
    \begin{itemize}
        \item Crea il foglio Bitmap
        \item Crea una lista e riempila con 10 quadratini casuali
        \item Crea un ostacolo al centro
        \item Avvia il timer
    \end{itemize}
    
    \item Nel \texttt{timer1\_Tick}, implementa il ciclo completo 
          con le tre fasi (cancella, ricalcola, disegna) usando 
          i cicli visti sopra.
\end{enumerate}
\end{esercizio}

\textbf{Bonus:} Prova ad aggiungere queste migliorie:

\begin{itemize}
    \item Un pulsante "Aggiungi Quadratino" che aggiunge un nuovo 
          quadratino alla lista mentre il programma è in esecuzione
    
    \item Un pulsante "Ferma/Riavvia" che attiva/disattiva il Timer
    
    \item Mostra il numero di quadratini attivi con una Label 
          (usa \texttt{quadratini.Count})
\end{itemize}

\subsection{Cosa abbiamo imparato in questa sezione avanzata}

\begin{itemize}
    \item Le \textbf{Liste} permettono di gestire un numero variabile 
          di oggetti senza sapere quanti saranno.
    
    \item Il ciclo \textbf{foreach} semplifica enormemente il codice 
          quando dobbiamo fare la stessa operazione su tutti gli elementi.
    
    \item Usiamo \textbf{for} quando dobbiamo modificare gli oggetti, 
          \textbf{foreach} quando dobbiamo solo leggerli.
    
    \item Con le Liste possiamo creare animazioni complesse con centinaia 
          di oggetti usando poche righe di codice!
\end{itemize}

\begin{consiglio}
\textbf{Il Progetto dei tuoi sogni}

Ora hai tutti gli strumenti per creare il TUO gioco o animazione! 
Pensa a cosa ti piacerebbe vedere:

\begin{itemize}
    \item Un simulatore di particelle colorate?
    \item Un gioco dove controlli un quadratino che deve evitare 
          gli altri?
    \item Una "pioggia" di quadratini che cadono dall'alto?
    \item Un labirinto con ostacoli da evitare?
\end{itemize}

Tutto quello che hai imparato in questa dispensa ti permette di 
realizzarlo. Sperimenta, prova, sbaglia e divertiti programmando!
\end{consiglio}

% ====================================
% CONCLUSIONE
% ====================================
\newpage
\section*{Conclusioni}
\addcontentsline{toc}{section}{Conclusioni}

In questa dispensa abbiamo imparato:

\begin{enumerate}
    \item Come creare interfacce grafiche con Windows Forms.
    
    \item Come gestire eventi (Click, KeyDown, Timer Tick).
    
    \item Come organizzare il codice con Classi e Liste.
    
    \item Come disegnare pixel per pixel usando Bitmap.
    
    \item Come creare animazioni fluide con il Timer.
    
    \item Come gestire collisioni e rimbalzi.
    
    \item Come coordinare multipli oggetti in movimento.
\end{enumerate}

\vspace{2cm}

% ====================================
% GLOSSARIO
% ====================================
\newpage
\section*{Glossario dei Termini}
\addcontentsline{toc}{section}{Glossario dei Termini}

\subsection*{A}

\textbf{Add (metodo)}: Comando che serve ad aggiungere un elemento a una Lista. 
Esempio: \texttt{nomi.Add("Mario");} aggiunge "Mario" alla lista \texttt{nomi}.

\textbf{Array}: Una collezione di elementi dello stesso tipo, di dimensione fissa. 
Esempio: \texttt{int[] numeri = new int[5];} crea un array di 5 numeri interi.

\subsection*{B}

\textbf{BackColor}: Proprietà che imposta il colore di sfondo di un controllo o della Form. 
Esempio: \texttt{this.BackColor = Color.Blue;} colora lo sfondo di blu.

\textbf{Bitmap}: Un'immagine digitale composta da una griglia di pixel. Nel nostro progetto, 
è il "foglio digitale" su cui disegniamo. Ogni pixel può avere un colore diverso.

\textbf{BorderStyle}: Proprietà che definisce il tipo di bordo di un controllo. 
Può essere \texttt{None} (nessun bordo), \texttt{FixedSingle} (linea singola) o 
\texttt{Fixed3D} (effetto tridimensionale).

\textbf{break}: Parola chiave che interrompe l'esecuzione di un ciclo o di un blocco 
\texttt{switch}. Serve per "uscire" immediatamente dal codice ripetitivo.

\textbf{Button (pulsante)}: Un controllo cliccabile che l'utente può premere per 
eseguire un'azione. Di solito gestito tramite l'evento \texttt{Click}.

\subsection*{C}

\textbf{case}: Usato dentro un blocco \texttt{switch}, rappresenta un possibile valore 
da confrontare. Ogni \texttt{case} deve terminare con \texttt{break}.

\textbf{Classe}: Il "progetto" o "stampo" che descrive come deve essere fatto un oggetto. 
Contiene proprietà (caratteristiche) e metodi (azioni). Esempio: la classe 
\texttt{Quadratino} descrive come è fatto un quadratino.

\textbf{Click (evento)}: Si attiva quando l'utente clicca su un controllo (come un Button). 
È l'evento più usato per far reagire il programma alle azioni dell'utente.

\textbf{Collisione}: Quando due oggetti (come un quadratino e un ostacolo) si toccano 
o si sovrappongono nello spazio. Gestiamo le collisioni confrontando le coordinate 
dei bordi degli oggetti.

\textbf{Color}: Tipo di dato che rappresenta un colore. C\# offre colori predefiniti 
come \texttt{Color.Red}, \texttt{Color.Blue}, oppure possiamo crearne di personalizzati 
con \texttt{Color.FromArgb(rosso, verde, blu)}.

\textbf{Component Tray}: La zona grigia sotto la Form nel designer di Visual Studio 
dove appaiono i componenti non visibili (come il Timer).

\textbf{Costruttore}: Un metodo speciale che viene eseguito automaticamente quando 
creiamo un nuovo oggetto. Ha lo stesso nome della classe e serve per inizializzare 
le proprietà. Esempio: \texttt{public Quadratino(int x, int y) \{ ... \}}.

\textbf{Controllo}: Un elemento visuale dell'interfaccia grafica (Button, Label, 
TextBox, ecc.) che l'utente può vedere e con cui può interagire.

\textbf{Coordinate}: Numeri che indicano la posizione di un punto sullo schermo. 
Usiamo \textbf{X} per la posizione orizzontale (da sinistra a destra) e \textbf{Y} 
per quella verticale (dall'alto in basso).

\textbf{Count}: Proprietà di una Lista che restituisce il numero di elementi contenuti. 
Esempio: \texttt{if (quadratini.Count > 10)} controlla se ci sono più di 10 quadratini.

\subsection*{D}

\textbf{DataSource}: Proprietà usata per collegare una Lista a un controllo visuale 
come la ListBox, mostrando automaticamente tutti gli elementi contenuti.

\textbf{Dimensione}: Grandezza di un oggetto, misurata in pixel. Per un quadrato, 
la dimensione rappresenta la lunghezza del lato.

\subsection*{E}

\textbf{Enabled}: Proprietà booleana (\texttt{true}/\texttt{false}) che attiva o 
disattiva un controllo. Per il Timer, \texttt{Enabled = true} lo fa partire, 
\texttt{Enabled = false} lo ferma.

\textbf{Evento}: Un'azione che accade durante l'esecuzione del programma (come un 
click del mouse o la pressione di un tasto). Gli eventi permettono al programma 
di reagire alle azioni dell'utente.

\subsection*{F}

\textbf{false}: Valore booleano che indica "falso" o "no". Usato nelle condizioni 
e per disattivare proprietà.

\textbf{for (ciclo)}: Struttura che ripete un blocco di codice un numero specifico 
di volte. Sintassi: \texttt{for (inizializzazione; condizione; incremento) \{ ... \}}.

\textbf{foreach (ciclo)}: Ciclo che scorre automaticamente tutti gli elementi di 
una collezione (come una Lista). Sintassi: \texttt{foreach (Tipo elemento in collezione) \{ ... \}}.

\textbf{Form}: La finestra principale di un'applicazione Windows Forms. È il contenitore 
che ospita tutti gli altri controlli (pulsanti, etichette, immagini, ecc.).

\textbf{Form1\_Load}: Evento che si attiva una sola volta, quando la Form viene 
caricata all'avvio del programma. Utile per inizializzare variabili e preparare 
l'interfaccia.

\textbf{Funzione}: Vedi \textit{Metodo}.

\subsection*{G}

\textbf{Graphics}: Classe che fornisce metodi avanzati per disegnare (linee, 
rettangoli, ellissi). Usiamo \texttt{Graphics.FromImage(bitmap)} per ottenere 
un oggetto Graphics da una Bitmap. Il metodo \texttt{Clear()} riempie l'intera 
immagine di un colore.

\textbf{GUI (Graphical User Interface)}: Interfaccia Grafica Utente. È il modo 
in cui l'utente interagisce con il programma attraverso finestre, pulsanti e 
altri elementi visuali, invece di scrivere comandi testuali.

\subsection*{H}

\textbf{Height}: Proprietà che indica l'altezza di un controllo o di un'immagine, 
misurata in pixel.

\subsection*{I}

\textbf{IDE (Integrated Development Environment)}: Ambiente di Sviluppo Integrato. 
Visual Studio è un IDE che ci fornisce tutti gli strumenti per scrivere, testare 
e pubblicare programmi.

\textbf{if (condizione)}: Struttura che esegue un blocco di codice solo se una 
condizione è vera. Sintassi: \texttt{if (condizione) \{ ... \} else \{ ... \}}.

\textbf{Image}: Proprietà della PictureBox che contiene l'immagine da visualizzare. 
Assegnando una Bitmap a questa proprietà, la mostriamo sullo schermo.

\textbf{Indice}: Numero che indica la posizione di un elemento in una Lista o Array. 
\textbf{Attenzione}: il computer inizia a contare da 0! Il primo elemento ha indice 0, 
il secondo ha indice 1, e così via.

\textbf{InitializeComponent()}: Metodo automatico che inizializza tutti i controlli 
della Form. Non va modificato manualmente, viene gestito da Visual Studio.

\textbf{int}: Tipo di dato che rappresenta un numero intero (senza decimali). 
Esempio: \texttt{int x = 10;}.

\textbf{Interval}: Proprietà del Timer che indica ogni quanti millisecondi (ms) 
scatta l'evento Tick. Esempio: \texttt{Interval = 20} significa 50 volte al secondo 
(1000ms ÷ 20 = 50).

\textbf{Istanza}: Un oggetto concreto creato da una classe. Esempio: \texttt{q1} 
e \texttt{q2} sono due istanze diverse della classe \texttt{Quadratino}.

\subsection*{K}

\textbf{KeyCode}: Proprietà dell'evento \texttt{KeyDown} che indica quale tasto 
è stato premuto. Esempi: \texttt{Keys.Up}, \texttt{Keys.Down}, \texttt{Keys.Left}, 
\texttt{Keys.Right}.

\textbf{KeyDown (evento)}: Si attiva quando l'utente preme un tasto sulla tastiera. 
Utile per controllare i movimenti in un gioco.

\textbf{KeyPreview}: Proprietà booleana della Form. Se impostata su \texttt{true}, 
la Form "intercetta" tutti i tasti premuti prima che arrivino ai controlli al suo interno.

\textbf{Keys}: Enumerazione che contiene tutti i codici dei tasti della tastiera. 
Usata con l'evento KeyDown per riconoscere quale tasto è stato premuto.

\subsection*{L}

\textbf{Label (etichetta)}: Controllo che mostra un testo fisso sullo schermo. 
L'utente non può modificarlo direttamente, ma possiamo cambiarlo nel codice 
tramite la proprietà \texttt{Text}.

\textbf{List<T>}: Collezione dinamica che può contenere un numero variabile di 
elementi dello stesso tipo. Esempio: \texttt{List<Quadratino>} può contenere 
tanti quadratini. Si può espandere o ridurre con \texttt{Add()} e \texttt{Remove()}.

\textbf{ListBox}: Controllo che mostra una lista di elementi a schermo. L'utente 
può scorrere e selezionare elementi dalla lista.

\textbf{Load (evento)}: Vedi \textit{Form1\_Load}.

\textbf{Location}: Proprietà che indica la posizione di un controllo sulla Form, 
espressa come coordinate X e Y.

\subsection*{M}

\textbf{MessageBox.Show()}: Metodo che mostra una finestra di dialogo con un 
messaggio. Utile per comunicare informazioni all'utente o per fare debugging.

\textbf{Metodo}: Un'azione che un oggetto può compiere. È un blocco di codice 
con un nome che possiamo "chiamare" per eseguirlo. Esempio: \texttt{DisegnaPunto()} 
è un metodo che disegna un punto sullo schermo.

\textbf{Millisecondi (ms)}: Millesimi di secondo. Usati per misurare l'Interval 
del Timer. 1000 ms = 1 secondo.

\subsection*{N}

\textbf{Name}: Proprietà che assegna un nome identificativo a un controllo. 
È consigliato usare nomi descrittivi come \texttt{btnInizia} invece di 
\texttt{button1}.

\textbf{new}: Parola chiave usata per creare un nuovo oggetto da una classe. 
Esempio: \texttt{Quadratino q = new Quadratino(10, 20, 2, 3, 15, Color.Red);}.

\textbf{null}: Valore speciale che indica "nessun oggetto" o "vuoto". Esempio: 
\texttt{if (o1 != null)} controlla se l'ostacolo esiste prima di usarlo.

\subsection*{O}

\textbf{Oggetto}: Un'entità concreta creata da una classe, con proprietà e metodi 
propri. Esempio: \texttt{q1} è un oggetto della classe \texttt{Quadratino}.

\textbf{Ostacolo}: Nel nostro progetto, un rettangolo fisso contro cui i quadratini 
possono rimbalzare. Definito dalla classe \texttt{Ostacolo} con coordinate degli 
angoli opposti.

\subsection*{P}

\textbf{Parametro}: Un valore che passiamo a un metodo quando lo chiamiamo. 
Esempio: in \texttt{disegnaPunto(100, 200)}, i numeri 100 e 200 sono parametri 
che indicano dove disegnare.

\textbf{PictureBox}: Controllo che può contenere e mostrare immagini. Nel nostro 
caso, lo usiamo come "tela" per disegnare animazioni pixel per pixel.

\textbf{Pixel}: Il più piccolo punto colorabile sullo schermo. Le immagini digitali 
sono composte da migliaia di pixel disposti in una griglia.

\textbf{Posizione}: Le coordinate (X, Y) che indicano dove si trova un oggetto 
sullo schermo o nell'area di disegno.

\textbf{private}: Parola chiave che indica che un metodo o una variabile è 
accessibile solo all'interno della classe in cui è dichiarato. Serve per proteggere 
il codice.

\textbf{Proprietà}: Una caratteristica di un oggetto (come il colore, la posizione, 
la dimensione). In C\#, le proprietà sono variabili dichiarate dentro una classe.

\textbf{public}: Parola chiave che indica che un metodo, una proprietà o una classe 
è accessibile da qualsiasi parte del programma.

\subsection*{R}

\textbf{Random}: Classe che genera numeri casuali. Esempio: 
\texttt{Random rnd = new Random(); int numero = rnd.Next(1, 101);} genera un 
numero tra 1 e 100.

\textbf{Refresh()}: Metodo che forza un controllo ad aggiornarsi immediatamente, 
ridisegnandosi sullo schermo.

\textbf{Remove}: Metodo che rimuove un elemento da una Lista. Esempio: 
\texttt{nomi.Remove("Mario");} toglie "Mario" dalla lista.

\textbf{return}: Parola chiave che termina l'esecuzione di un metodo e, 
opzionalmente, restituisce un valore. Esempio: \texttt{return x + y;}.

\textbf{Rimbalzo}: Cambio di direzione di un oggetto in movimento quando tocca 
un bordo o un ostacolo. Si ottiene invertendo il segno della velocità: 
\texttt{vx = -vx}.

\subsection*{S}

\textbf{SetPixel}: Metodo della classe Bitmap che colora un singolo pixel in una 
posizione specifica. Sintassi: \texttt{bitmap.SetPixel(x, y, colore)}.

\textbf{Size}: Proprietà che indica la dimensione (larghezza e altezza) di un 
controllo o di un'immagine.

\textbf{string}: Tipo di dato che rappresenta una stringa di testo. Esempio: 
\texttt{string nome = "Mario";}.

\textbf{switch}: Struttura di controllo che esegue blocchi di codice diversi in 
base al valore di una variabile. Più elegante di tanti \texttt{if-else} consecutivi.

\subsection*{T}

\textbf{Text}: Proprietà che contiene il testo visualizzato in un controllo 
(Label, Button, TextBox, Form). Possiamo leggerla e modificarla nel codice.

\textbf{TextBox}: Controllo che permette all'utente di inserire testo. La proprietà 
\texttt{Text} contiene quello che l'utente ha scritto.

\textbf{this}: Parola chiave che si riferisce all'oggetto corrente. In una Form, 
\texttt{this} indica la Form stessa. Esempio: \texttt{this.BackColor = Color.Red;}.

\textbf{Tick (evento)}: Evento del Timer che si attiva periodicamente secondo 
l'intervallo impostato. È il "battito" del Timer, usato per creare animazioni.

\textbf{Timer}: Componente che genera eventi ripetuti a intervalli regolari. 
Fondamentale per creare animazioni e giochi.

\textbf{Toolbox}: La finestra di Visual Studio (di solito a sinistra) che contiene 
tutti i controlli che possiamo trascinare sulla Form.

\textbf{true}: Valore booleano che indica "vero" o "sì". Usato nelle condizioni 
e per attivare proprietà.

\subsection*{U}

\textbf{using}: Può avere due significati:
\begin{enumerate}
    \item All'inizio del file: importa uno spazio dei nomi (namespace) per 
          usare le sue classi. Esempio: \texttt{using System.Drawing;}.
    \item Nel codice: gestisce automaticamente la pulizia di risorse. Esempio: 
          \texttt{using (Graphics g = ...) \{ ... \}} chiude automaticamente 
          l'oggetto Graphics.
\end{enumerate}

\subsection*{V}

\textbf{Variabile}: Un contenitore con un nome che conserva un valore. Può essere 
modificata durante l'esecuzione del programma. Esempio: \texttt{int x = 10;}.

\textbf{Variabile Globale (o di Classe)}: Variabile dichiarata fuori dai metodi, 
accessibile da tutta la classe. Mantiene il suo valore per tutta la durata del 
programma.

\textbf{Variabile Locale}: Variabile dichiarata dentro un metodo, accessibile solo 
in quel metodo. Viene distrutta quando il metodo termina.

\textbf{Velocità}: Nel nostro progetto, indica di quanti pixel si sposta un oggetto 
a ogni aggiornamento. Usiamo \texttt{vx} per la velocità orizzontale e \texttt{vy} 
per quella verticale.

\textbf{void}: Parola chiave che indica che un metodo non restituisce nessun valore. 
Esempio: \texttt{private void DisegnaPunto() \{ ... \}}.

\subsection*{W}

\textbf{Width}: Proprietà che indica la larghezza di un controllo o di un'immagine, 
misurata in pixel.

\textbf{WinForms (Windows Forms)}: Tecnologia di Microsoft per creare applicazioni 
desktop con interfaccia grafica per Windows.

\subsection*{X, Y, Z}

\textbf{X (coordinata)}: Posizione orizzontale di un punto, misurata in pixel da 
sinistra (valore 0) verso destra.

\textbf{Y (coordinata)}: Posizione verticale di un punto, misurata in pixel dall'alto 
(valore 0) verso il basso.

\begin{consiglio}
\textbf{Come usare questo glossario:}

\begin{itemize}
    \item Quando incontri un termine che non conosci nel codice, cerca qui la 
          sua definizione.
    \item Rileggi le definizioni periodicamente per consolidare la tua comprensione.
    \item Prova a spiegare ogni termine con parole tue: è il modo migliore per 
          verificare di averlo capito!
    \item I termini in \textit{corsivo} rimandano ad altre voci del glossario.
\end{itemize}
\end{consiglio}

\begin{center}
{\Large\textit{Ora sei pronto per creare i tuoi primi giochi e applicazioni interattive!}}

\vspace{1cm}
{\LARGE\textbf{Buona programmazione!}}
\end{center}

\end{document}
